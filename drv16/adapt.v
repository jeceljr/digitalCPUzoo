/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// adapts values out of registers for the ALU
module adapt (
  input [15:0] Da,
  input [15:0] Db,
  input [11:0] topImm, // bits saved from prefix
  input [3:0] rD, // rD field from current instruction
  input [3:0] rS2, // rS2 field from instruction
  input even, // force even values for PC math
  input const2, // changes 0 to 2 to increment the PC
  input selImm, // operand B is an immediate
  input selConst, // selects either 0 or 2
  input Azero,
  input immLow,
  output [15:0] A,
  output [15:0] B,
  output alt // lowest bit indicates alternative branch instruction

);
  wire [3:0] s0;
  wire alt_temp;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( Azero ),
    .in_0( Da ),
    .in_1( 16'b0 ),
    .out( A )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( immLow ),
    .in_0( rS2 ),
    .in_1( rD ),
    .out( s0 )
  );
  assign s2[0] = 1'b0;
  assign s2[1] = const2;
  assign s2[15:2] = 14'b0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( selConst ),
    .in_0( Db ),
    .in_1( s2 ),
    .out( s3 )
  );
  assign alt_temp = s0[0];
  assign s1[0] = (even & alt_temp);
  assign s1[3:1] = s0[3:1];
  assign s1[15:4] = topImm;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( selImm ),
    .in_0( s3 ),
    .in_1( s1 ),
    .out( B )
  );
  assign alt = alt_temp;
endmodule
