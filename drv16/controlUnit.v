/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// allows an instruction's register field to be replaced by the PC (register zero) and detects when special handling is needed
module r0 (
  input [3:0] rin, // a register field from the instruction
  input pc, // replaced incoming register with 0 (pc)
  output [3:0] rout, // register field for the rest of the processor
  output z // indicates that rin was zero and pc was not selected

);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( pc ),
    .in_0( rin ),
    .in_1( 4'b0 ),
    .out( rout )
  );
  assign z = (~ pc & ~ rin[0] & ~ rin[1] & ~ rin[2] & ~ rin[3]);
endmodule

// generates control signals for datapath
module controlUnit (
  input clock, // controls internal registers
  input reset, // when high forces the PC to 0x0000
  input [15:0] dIn, // data from memory
  input alt, // immediate value indicates alternative instruction in lowest bit
  input NE, // A ~= B
  input GE, // A >= B
  output wr, // memory write cycle
  output rd, // memory read cycle
  output sign, // not LBU
  output word, // not SB, LB or LBU
  output sub, // change addition to subtraction
  output logic, // select logic operation instead of addition
  output [1:0] logSelect, // selects between shift right, AND, OR, XOR
  output [11:0] topImm, // saved from prefix instruction
  output even, // forces bottom bit of immediate to 0
  output const2, // changes constant from 0 to 2
  output selImm, // B is immediate
  output selConst, // B is a constant
  output Azero, // force A to 0
  output we, // updates register Rw
  output [3:0] Rw, // register to be written
  output [3:0] Ra, // first register to read
  output [3:0] Rb, // second register to read
  output selRd, // selects betweenALU result and memory for write back
  output slt, // ignores ALU result and use GE?0x0000:0x0001
  output immLow // selects either field rS2 or rD for the 4 lower bits of immediate

);
  wire word_temp;
  wire const2_temp;
  wire [3:0] Rb_temp;
  wire F;
  wire [15:0] s0;
  wire [11:0] s1;
  wire [3:0] s2;
  wire [11:0] s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire E;
  wire s6;
  wire zD;
  wire s7;
  wire zS1;
  wire IR1;
  wire IR2;
  wire IR3;
  wire zS2;
  wire branch;
  wire s8;
  wire s9;
  wire cond;
  wire EJ;
  wire s10;
  wire FJorBT;
  wire s11;
  wire s12;
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i0 (
    .D( dIn ),
    .C( clock ),
    .en( F ),
    .Q( s0 )
  );
  // IM
  DIG_D_FF_Nbit #(
    .Bits(12),
    .Default(0)
  )
  DIG_D_FF_Nbit_i1 (
    .D( s1 ),
    .C( clock ),
    .Q( topImm )
  );
  // fetch
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s6 ),
    .C( clock ),
    .Q( F ),
    .\~Q ( E )
  );
  assign s6 = (E | reset | (~ dIn[0] & ~ dIn[1] & ~ dIn[2] & ~ dIn[3] & F));
  Mux_2x1 Mux_2x1_i3 (
    .sel( word_temp ),
    .in_0( NE ),
    .in_1( GE ),
    .out( s8 )
  );
  assign s9 = (s8 ^ alt);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s9 ),
    .C( clock ),
    .Q( cond )
  );
  assign s7 = ((F & ~ (s10 & alt)) | EJ);
  assign const2_temp = ((F & ~ reset) | EJ);
  // prefix
  DIG_Register DIG_Register_i5 (
    .D( s11 ),
    .C( clock ),
    .en( F ),
    .Q( s12 )
  );
  assign s2 = s0[3:0];
  assign s3 = s0[15:4];
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i6 (
    .sel( E ),
    .in_0( s3 ),
    .in_1( 12'b0 ),
    .out( s1 )
  );
  assign Rb_temp = s3[3:0];
  assign s4 = s3[7:4];
  assign s5 = s3[11:8];
  assign word_temp = s2[0];
  assign IR1 = s2[1];
  assign IR2 = s2[2];
  assign IR3 = s2[3];
  r0 r0_i7 (
    .rin( s5 ),
    .pc( F ),
    .rout( Rw ),
    .z( zD )
  );
  r0 r0_i8 (
    .rin( s4 ),
    .pc( s7 ),
    .rout( Ra ),
    .z( zS1 )
  );
  assign zS2 = (~ Rb_temp[0] & ~ Rb_temp[1] & ~ Rb_temp[2] & ~ Rb_temp[3]);
  assign sub = (E & ~ IR2 & IR1);
  assign wr = (E & ~ IR3 & IR2 & IR1);
  assign rd = (F | ~ IR1);
  assign sign = ~ IR3;
  assign logSelect[0] = word_temp;
  assign logSelect[1] = IR1;
  assign logic = (E & IR3 & IR2);
  assign slt = (E & ~ IR2 & IR1 & word_temp);
  assign selRd = ((E & ~ IR2 & ~ IR1 & ~ word_temp) | (E & ~ IR3 & IR2));
  assign branch = (~ IR3 & ~ IR2 & IR1);
  assign s10 = (~ IR3 & ~ IR2 & ~ IR1 & word_temp);
  assign s11 = (~ IR3 & ~ IR2 & ~ IR1 & ~ word_temp);
  assign immLow = (F & branch);
  assign we = ~ (E & branch);
  assign EJ = (E & s10);
  assign FJorBT = ((F & s10) | (F & branch & cond));
  assign selConst = (EJ | (F & ~ FJorBT));
  assign selImm = (FJorBT | (~ EJ & E & (s12 | ~ IR3)));
  assign word = word_temp;
  assign even = const2_temp;
  assign const2 = const2_temp;
  assign Azero = reset;
  assign Rb = Rb_temp;
endmodule
