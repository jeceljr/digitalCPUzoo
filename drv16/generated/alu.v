/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// implements all the math and logic functions
module alu (
  input [15:0] A, // first operand
  input [15:0] B, // second operand
  input sub, // changes addition to subtraction
  input [1:0] logSelect, // selects between logic functions
  input logic, // logic functions instead of addition
  output [15:0] R, // result
  output NE, // when used with a subtraction indicates that the operands are Not Equal
  output GE // when used with a subtraction, indicates A>= B signed

);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] R_temp;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire [3:0] s11;
  wire [3:0] s12;
  assign s4 = (A & B);
  assign s5 = (A | B);
  assign s6 = (A ^ B);
  assign s8[0] = sub;
  assign s8[1] = sub;
  assign s8[2] = sub;
  assign s8[3] = sub;
  assign s3[14:0] = A[15:1];
  assign s3[15] = B[15];
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( logSelect ),
    .in_0( s3 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s6 ),
    .out( s2 )
  );
  assign s7[3:0] = s8;
  assign s7[7:4] = s8;
  assign s7[11:8] = s8;
  assign s7[15:12] = s8;
  assign s0 = (s7 ^ B);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i1 (
    .a( A ),
    .b( s0 ),
    .c_i( sub ),
    .s( s1 ),
    .c_o( GE )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( logic ),
    .in_0( s1 ),
    .in_1( s2 ),
    .out( R_temp )
  );
  assign s9 = R_temp[3:0];
  assign s10 = R_temp[7:4];
  assign s11 = R_temp[11:8];
  assign s12 = R_temp[15:12];
  assign NE = ((s9[0] | s9[1] | s9[2] | s9[3]) | (s10[0] | s10[1] | s10[2] | s10[3]) | (s11[0] | s11[1] | s11[2] | s11[3]) | (s12[0] | s12[1] | s12[2] | s12[3]));
  assign R = R_temp;
endmodule
