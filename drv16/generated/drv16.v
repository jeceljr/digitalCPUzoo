/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// allows an instruction's register field to be replaced by the PC (register zero) and detects when special handling is needed
module r0 (
  input [3:0] rin, // a register field from the instruction
  input pc, // replaced incoming register with 0 (pc)
  output [3:0] rout, // register field for the rest of the processor
  output z // indicates that rin was zero and pc was not selected

);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( pc ),
    .in_0( rin ),
    .in_1( 4'b0 ),
    .out( rout )
  );
  assign z = (~ pc & ~ rin[0] & ~ rin[1] & ~ rin[2] & ~ rin[3]);
endmodule

// generates control signals for execution cycles (created by Digital from truth table)
module execPLA (
  input IR3,
  input IR2,
  input IR1,
  input IR0,
  input imm,
  output selImm,
  output selConst,
  output sub,
  output logic,
  output aPC,
  output lowImm,
  output rd,
  output wr,
  output we,
  output sign,
  output word,
  output selRd,
  output slt
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  assign logic = (IR2 & IR3);
  assign s3 = ~ IR3;
  assign s2 = ~ IR2;
  assign s1 = ~ IR1;
  assign s0 = ~ IR0;
  assign selImm = ((s0 & s1 & s2) | (s1 & s3) | (IR2 & s3) | (IR3 & imm));
  assign selConst = (s2 & s3);
  assign sub = (IR1 & s2);
  assign aPC = (IR0 & s1 & s2 & s3);
  assign lowImm = (IR1 & s3);
  assign rd = ((s0 & s1 & s2) | (s1 & IR2 & s3));
  assign wr = (IR1 & IR2 & s3);
  assign we = (s1 | IR3);
  assign selRd = ((s0 & s1 & s2) | (IR2 & s3));
  assign slt = (IR0 & IR1 & s2);
  assign sign = IR2;
  assign word = IR0;
endmodule

// generates control signals for datapath
module controlUnit (
  input clock, // controls internal registers
  input reset, // when high forces the PC to 0x0000
  input [15:0] dIn, // data from memory
  input NE, // A ~= B
  input GE, // A >= B
  output wr, // memory write cycle
  output rd, // memory read cycle
  output sign, // not LBU
  output word, // not SB, LB or LBU
  output sub, // change addition to subtraction
  output logic, // select logic operation instead of addition
  output [1:0] logSelect, // selects between shift right, AND, OR, XOR
  output [15:0] Imm, // saved from prefix instruction and 4 bits from the current instruction
  output selImm, // B is immediate
  output Azero, // force A to 0
  output we, // updates register Rw
  output [3:0] Rw, // register to be written
  output [3:0] Ra, // first register to read
  output [3:0] Rb, // second register to read
  output selRd, // selects betweenALU result and memory for write back
  output slt // ignores ALU result and use GE?0x0000:0x0001

);
  wire [3:0] Rb_temp;
  wire F;
  wire [15:0] s0;
  wire [3:0] s1;
  wire [11:0] s2;
  wire [3:0] s3;
  wire [3:0] s4;
  wire s5;
  wire [11:0] s6;
  wire s7;
  wire E;
  wire rst;
  wire zD;
  wire s8;
  wire zS1;
  wire IR0;
  wire IR1;
  wire IR2;
  wire IR3;
  wire s9;
  wire alt;
  wire s10;
  wire cond;
  wire s11;
  wire s12;
  wire s_imm;
  wire [11:0] s13;
  wire s14;
  wire [3:0] s15;
  wire [15:0] s16;
  wire s17;
  wire [15:0] s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire [12:0] s32;
  wire [12:0] s33;
  wire [12:0] s34;
  wire s35;
  wire JorB;
  wire s36;
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i0 (
    .D( reset ),
    .C( clock ),
    .Q( rst )
  );
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( dIn ),
    .C( clock ),
    .en( F ),
    .Q( s0 )
  );
  // fetch
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s7 ),
    .C( clock ),
    .Q( F ),
    .\~Q ( E )
  );
  assign s7 = (E | rst | (~ dIn[0] & ~ dIn[1] & ~ dIn[2] & ~ dIn[3] & F));
  Mux_2x1 Mux_2x1_i3 (
    .sel( IR0 ),
    .in_0( NE ),
    .in_1( GE ),
    .out( s9 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s10 ),
    .C( clock ),
    .Q( cond )
  );
  // prefix
  DIG_Register DIG_Register_i5 (
    .D( s11 ),
    .C( clock ),
    .en( F ),
    .Q( s12 )
  );
  // IM
  DIG_Register_BUS #(
    .Bits(12)
  )
  DIG_Register_BUS_i6 (
    .D( s6 ),
    .C( clock ),
    .en( F ),
    .Q( s13 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i7 (
    .D( E ),
    .C( clock ),
    .Q( s5 )
  );
  assign Azero = (rst | (~ s8 & zS1));
  assign s18[0] = 1'b0;
  assign s18[1] = ~ (s36 | rst);
  assign s18[15:2] = 14'b0;
  assign s33[0] = 1'b1;
  assign s33[1] = ((IR1 & ~ cond) | ~ JorB | rst);
  assign s33[2] = 1'b0;
  assign s33[3] = 1'b0;
  assign s33[4] = (IR1 | ~ JorB | ~ alt);
  assign s33[5] = (IR1 & JorB);
  assign s33[6] = 1'b1;
  assign s33[7] = 1'b0;
  assign s33[8] = 1'b1;
  assign s33[9] = 1'b0;
  assign s33[10] = 1'b0;
  assign s33[11] = 1'b0;
  assign s33[12] = 1'b0;
  assign s1 = s0[3:0];
  assign s2 = s0[15:4];
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i8 (
    .sel( s5 ),
    .in_0( s2 ),
    .in_1( 12'b0 ),
    .out( s6 )
  );
  assign Rb_temp = s2[3:0];
  assign s3 = s2[7:4];
  assign s4 = s2[11:8];
  assign IR0 = s1[0];
  assign IR1 = s1[1];
  assign IR2 = s1[2];
  assign IR3 = s1[3];
  r0 r0_i9 (
    .rin( s4 ),
    .pc( F ),
    .rout( Rw ),
    .z( zD )
  );
  assign s11 = (~ IR3 & ~ IR2 & ~ IR1 & ~ IR0);
  assign s_imm = (s12 | ~ IR3);
  assign JorB = (~ IR3 & ~ IR2 & (IR1 | IR0));
  assign logSelect[0] = IR1;
  assign logSelect[1] = IR0;
  execPLA execPLA_i10 (
    .IR3( IR3 ),
    .IR2( IR2 ),
    .IR1( IR1 ),
    .IR0( IR0 ),
    .imm( s_imm ),
    .selImm( s19 ),
    .selConst( s20 ),
    .sub( s21 ),
    .logic( s22 ),
    .aPC( s23 ),
    .lowImm( s24 ),
    .rd( s25 ),
    .wr( s26 ),
    .we( s27 ),
    .sign( s28 ),
    .word( s29 ),
    .selRd( s30 ),
    .slt( s31 )
  );
  assign s32[0] = s19;
  assign s32[1] = s20;
  assign s32[2] = s21;
  assign s32[3] = s22;
  assign s32[4] = s23;
  assign s32[5] = s24;
  assign s32[6] = s25;
  assign s32[7] = s26;
  assign s32[8] = (~ zD & s27);
  assign s32[9] = s28;
  assign s32[10] = s29;
  assign s32[11] = s30;
  assign s32[12] = s31;
  Mux_2x1_NBits #(
    .Bits(13)
  )
  Mux_2x1_NBits_i11 (
    .sel( F ),
    .in_0( s32 ),
    .in_1( s33 ),
    .out( s34 )
  );
  assign s35 = s34[0];
  assign sub = s34[2];
  assign logic = s34[3];
  assign s8 = s34[4];
  assign s14 = s34[5];
  assign rd = s34[6];
  assign wr = s34[7];
  assign we = s34[8];
  assign sign = s34[9];
  assign word = s34[10];
  assign selRd = s34[11];
  assign slt = s34[12];
  r0 r0_i12 (
    .rin( s3 ),
    .pc( s8 ),
    .rout( Ra ),
    .z( zS1 )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i13 (
    .sel( s14 ),
    .in_0( Rb_temp ),
    .in_1( s4 ),
    .out( s15 )
  );
  assign s36 = (~ F & (~ Rb_temp[0] & ~ Rb_temp[1] & ~ Rb_temp[2] & ~ Rb_temp[3]) & ~ s35);
  assign selImm = (s36 | s35);
  assign s17 = (s36 | s34[1]);
  assign alt = s15[0];
  assign s10 = (s9 ^ ~ alt);
  assign s16[0] = (~ ((JorB & ~ F) | F) & alt);
  assign s16[3:1] = s15[3:1];
  assign s16[15:4] = s13;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i14 (
    .sel( s17 ),
    .in_0( s16 ),
    .in_1( s18 ),
    .out( Imm )
  );
  assign Rb = Rb_temp;
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



// implements all the math and logic functions
module alu (
  input [15:0] A, // first operand
  input [15:0] B, // second operand
  input sub, // changes addition to subtraction
  input [1:0] logSelect, // selects between logic functions
  input logic, // logic functions instead of addition
  output [15:0] R, // result
  output NE, // when used with a subtraction indicates that the operands are Not Equal
  output GE // when used with a subtraction, indicates A>= B signed

);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] R_temp;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire [3:0] s11;
  wire [3:0] s12;
  assign s4 = (A & B);
  assign s5 = (A | B);
  assign s6 = (A ^ B);
  assign s8[0] = sub;
  assign s8[1] = sub;
  assign s8[2] = sub;
  assign s8[3] = sub;
  assign s3[14:0] = A[15:1];
  assign s3[15] = B[15];
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( logSelect ),
    .in_0( s3 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s6 ),
    .out( s2 )
  );
  assign s7[3:0] = s8;
  assign s7[7:4] = s8;
  assign s7[11:8] = s8;
  assign s7[15:12] = s8;
  assign s0 = (s7 ^ B);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i1 (
    .a( A ),
    .b( s0 ),
    .c_i( sub ),
    .s( s1 ),
    .c_o( GE )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( logic ),
    .in_0( s1 ),
    .in_1( s2 ),
    .out( R_temp )
  );
  assign s9 = R_temp[3:0];
  assign s10 = R_temp[7:4];
  assign s11 = R_temp[11:8];
  assign s12 = R_temp[15:12];
  assign NE = ((s9[0] | s9[1] | s9[2] | s9[3]) | (s10[0] | s10[1] | s10[2] | s10[3]) | (s11[0] | s11[1] | s11[2] | s11[3]) | (s12[0] | s12[1] | s12[2] | s12[3]));
  assign R = R_temp;
endmodule

// 16 bit processor which is compatible at the assembly language level with RISC-V
module drv16 (
  input clock,
  input reset, // when high prepares the processor to execute from address 0
  input [15:0] dIn, // word coming from memory
  output [14:0] addr, // selects a 16 bit word in memory to be read or changed
  output [15:0] dOut, // word to be sent to memory
  output rd, // indicates that memory will be read in this cycle
  output wrH,
  output wrL
);
  wire [15:0] s0;
  wire s1;
  wire [15:0] s2;
  wire s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire [15:0] s7;
  wire [15:0] s8;
  wire s9;
  wire s10;
  wire [15:0] s11;
  wire [15:0] s12;
  wire s13;
  wire [1:0] s14;
  wire s15;
  wire s16;
  wire [15:0] s17;
  wire [15:0] s18;
  wire s19;
  wire s20;
  wire s21;
  wire [15:0] s22;
  wire s23;
  wire s24;
  wire s25;
  wire [15:0] s26;
  wire [7:0] s27;
  wire [7:0] s28;
  wire [7:0] s29;
  wire [7:0] s30;
  wire [7:0] s31;
  wire s32;
  wire [7:0] s33;
  wire [7:0] s34;
  wire [7:0] s35;
  wire s36;
  assign s27 = dIn[7:0];
  assign s28 = dIn[15:8];
  controlUnit controlUnit_i0 (
    .clock( clock ),
    .reset( reset ),
    .dIn( dIn ),
    .NE( s9 ),
    .GE( s10 ),
    .wr( s19 ),
    .rd( rd ),
    .sign( s20 ),
    .word( s21 ),
    .sub( s13 ),
    .logic( s15 ),
    .logSelect( s14 ),
    .Imm( s22 ),
    .selImm( s23 ),
    .Azero( s24 ),
    .we( s3 ),
    .Rw( s4 ),
    .Ra( s5 ),
    .Rb( s6 ),
    .selRd( s16 ),
    .slt( s25 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i1 (
    .sel( s1 ),
    .in_0( s27 ),
    .in_1( s28 ),
    .out( s29 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i2 (
    .sel( s21 ),
    .in_0( s30 ),
    .in_1( s28 ),
    .out( s31 )
  );
  assign s18[7:0] = s29;
  assign s18[15:8] = s31;
  assign s32 = (s29[7] & s20);
  assign s36 = (s21 & s19);
  assign s30[0] = s32;
  assign s30[1] = s32;
  assign s30[2] = s32;
  assign s30[3] = s32;
  assign s30[4] = s32;
  assign s30[5] = s32;
  assign s30[6] = s32;
  assign s30[7] = s32;
  DIG_RegisterFile #(
    .Bits(16),
    .AddrBits(4)
  )
  DIG_RegisterFile_i3 (
    .Din( s2 ),
    .we( s3 ),
    .Rw( s4 ),
    .C( clock ),
    .Ra( s5 ),
    .Rb( s6 ),
    .Da( s7 ),
    .Db( s8 )
  );
  // ALU
  alu alu_i4 (
    .A( s11 ),
    .B( s12 ),
    .sub( s13 ),
    .logSelect( s14 ),
    .logic( s15 ),
    .R( s0 ),
    .NE( s9 ),
    .GE( s10 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i5 (
    .sel( s16 ),
    .in_0( s17 ),
    .in_1( s18 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i6 (
    .sel( s25 ),
    .in_0( s0 ),
    .in_1( s26 ),
    .out( s17 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i7 (
    .sel( s24 ),
    .in_0( s7 ),
    .in_1( 16'b0 ),
    .out( s11 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i8 (
    .sel( s23 ),
    .in_0( s8 ),
    .in_1( s22 ),
    .out( s12 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i9 (
    .sel( s21 ),
    .in_0( s33 ),
    .in_1( s35 ),
    .out( s34 )
  );
  assign wrH = ((s1 & s19) | s36);
  assign wrL = (s36 | (~ s1 & s19));
  assign s26[0] = ~ s10;
  assign s26[15:1] = 15'b0;
  assign s1 = s0[0];
  assign addr = s0[15:1];
  assign s33 = s8[7:0];
  assign s35 = s8[15:8];
  assign dOut[7:0] = s33;
  assign dOut[15:8] = s34;
endmodule
