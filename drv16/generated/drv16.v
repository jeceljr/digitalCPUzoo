/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


// converts internal word data into bytes for LB, LBU and SB instructions
module bytes (
  input [15:0] dIn, // word coming from memory
  input sign, // indicates that the byte extension should be signed
  input word, // word memory access (not byte)
  input A0, // selects between even and odd bytes
  input [15:0] fromRS2, // word data from register (top 8 bits will be ignored on byte access)
  output [15:0] dOut, // word to be sent to memory
  output [15:0] toRD // bytes to word

);
  wire [7:0] s0;
  wire [7:0] s1;
  wire [7:0] s2;
  wire [7:0] s3;
  wire [7:0] s4;
  wire [7:0] s5;
  wire [7:0] s6;
  wire [7:0] s7;
  wire [7:0] s8;
  wire [7:0] s9;
  wire s10;
  assign s1 = dIn[7:0];
  assign s6 = dIn[15:8];
  assign s0 = fromRS2[7:0];
  assign s4 = fromRS2[15:8];
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i0 (
    .sel( A0 ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i1 (
    .sel( A0 ),
    .in_0( s6 ),
    .in_1( s0 ),
    .out( s3 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i2 (
    .sel( A0 ),
    .in_0( s1 ),
    .in_1( s6 ),
    .out( s7 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i3 (
    .sel( word ),
    .in_0( s3 ),
    .in_1( s4 ),
    .out( s5 )
  );
  assign s10 = (s7[7] & sign);
  assign dOut[7:0] = s2;
  assign dOut[15:8] = s5;
  assign s8[0] = s10;
  assign s8[1] = s10;
  assign s8[2] = s10;
  assign s8[3] = s10;
  assign s8[4] = s10;
  assign s8[5] = s10;
  assign s8[6] = s10;
  assign s8[7] = s10;
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i4 (
    .sel( word ),
    .in_0( s8 ),
    .in_1( s6 ),
    .out( s9 )
  );
  assign toRD[7:0] = s7;
  assign toRD[15:8] = s9;
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

// allows an instruction's register field to be replaced by the PC (register zero) and detects when special handling is needed
module r0 (
  input [3:0] rin, // a register field from the instruction
  input pc, // replaced incoming register with 0 (pc)
  output [3:0] rout, // register field for the rest of the processor
  output z // indicates that rin was zero and pc was not selected

);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( pc ),
    .in_0( rin ),
    .in_1( 4'b0 ),
    .out( rout )
  );
  assign z = (~ pc & ~ rin[0] & ~ rin[1] & ~ rin[2] & ~ rin[3]);
endmodule

// generates control signals for datapath
module controlUnit (
  input clock, // controls internal registers
  input reset, // when high forces the PC to 0x0000
  input [15:0] dIn, // data from memory
  input alt, // immediate value indicates alternative instruction in lowest bit
  input NE, // A ~= B
  input GE, // A >= B
  output wr, // memory write cycle
  output rd, // memory read cycle
  output sign, // not LBU
  output word, // not SB, LB or LBU
  output sub, // change addition to subtraction
  output logic, // select logic operation instead of addition
  output [1:0] logSelect, // selects between shift right, AND, OR, XOR
  output [11:0] topImm, // saved from prefix instruction
  output even, // forces bottom bit of immediate to 0
  output const2, // changes constant from 0 to 2
  output selImm, // B is immediate
  output selConst, // B is a constant
  output Azero, // force A to 0
  output we, // updates register Rw
  output [3:0] Rw, // register to be written
  output [3:0] Ra, // first register to read
  output [3:0] Rb, // second register to read
  output selRd, // selects betweenALU result and memory for write back
  output slt, // ignores ALU result and use GE?0x0000:0x0001
  output immLow // selects either field rS2 or rD for the 4 lower bits of immediate

);
  wire word_temp;
  wire const2_temp;
  wire [3:0] Rb_temp;
  wire F;
  wire [15:0] s0;
  wire [11:0] s1;
  wire [3:0] s2;
  wire [11:0] s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire E;
  wire s6;
  wire zD;
  wire s7;
  wire zS1;
  wire IR1;
  wire IR2;
  wire IR3;
  wire zS2;
  wire branch;
  wire s8;
  wire s9;
  wire cond;
  wire EJ;
  wire s10;
  wire FJorBT;
  wire s11;
  wire s12;
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i0 (
    .D( dIn ),
    .C( clock ),
    .en( F ),
    .Q( s0 )
  );
  // IM
  DIG_D_FF_Nbit #(
    .Bits(12),
    .Default(0)
  )
  DIG_D_FF_Nbit_i1 (
    .D( s1 ),
    .C( clock ),
    .Q( topImm )
  );
  // fetch
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i2 (
    .D( s6 ),
    .C( clock ),
    .Q( F ),
    .\~Q ( E )
  );
  assign s6 = (E | reset | (~ dIn[0] & ~ dIn[1] & ~ dIn[2] & ~ dIn[3] & F));
  Mux_2x1 Mux_2x1_i3 (
    .sel( word_temp ),
    .in_0( NE ),
    .in_1( GE ),
    .out( s8 )
  );
  assign s9 = (s8 ^ alt);
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i4 (
    .D( s9 ),
    .C( clock ),
    .Q( cond )
  );
  assign s7 = ((F & ~ (s10 & alt)) | EJ);
  assign const2_temp = ((F & ~ reset) | EJ);
  // prefix
  DIG_Register DIG_Register_i5 (
    .D( s11 ),
    .C( clock ),
    .en( F ),
    .Q( s12 )
  );
  assign s2 = s0[3:0];
  assign s3 = s0[15:4];
  Mux_2x1_NBits #(
    .Bits(12)
  )
  Mux_2x1_NBits_i6 (
    .sel( E ),
    .in_0( s3 ),
    .in_1( 12'b0 ),
    .out( s1 )
  );
  assign Rb_temp = s3[3:0];
  assign s4 = s3[7:4];
  assign s5 = s3[11:8];
  assign word_temp = s2[0];
  assign IR1 = s2[1];
  assign IR2 = s2[2];
  assign IR3 = s2[3];
  r0 r0_i7 (
    .rin( s5 ),
    .pc( F ),
    .rout( Rw ),
    .z( zD )
  );
  r0 r0_i8 (
    .rin( s4 ),
    .pc( s7 ),
    .rout( Ra ),
    .z( zS1 )
  );
  assign zS2 = (~ Rb_temp[0] & ~ Rb_temp[1] & ~ Rb_temp[2] & ~ Rb_temp[3]);
  assign sub = (E & ~ IR2 & IR1);
  assign wr = (E & ~ IR3 & IR2 & IR1);
  assign rd = (F | ~ IR1);
  assign sign = ~ IR3;
  assign logSelect[0] = word_temp;
  assign logSelect[1] = IR1;
  assign logic = (E & IR3 & IR2);
  assign slt = (E & ~ IR2 & IR1 & word_temp);
  assign selRd = ((E & ~ IR2 & ~ IR1 & ~ word_temp) | (E & ~ IR3 & IR2));
  assign branch = (~ IR3 & ~ IR2 & IR1);
  assign s10 = (~ IR3 & ~ IR2 & ~ IR1 & word_temp);
  assign s11 = (~ IR3 & ~ IR2 & ~ IR1 & ~ word_temp);
  assign immLow = (F & branch);
  assign we = ~ (E & branch);
  assign EJ = (E & s10);
  assign FJorBT = ((F & s10) | (F & branch & cond));
  assign selConst = (EJ | (F & ~ FJorBT));
  assign selImm = (FJorBT | (~ EJ & E & (s12 | ~ IR3)));
  assign word = word_temp;
  assign even = const2_temp;
  assign const2 = const2_temp;
  assign Azero = reset;
  assign Rb = Rb_temp;
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



// implements all the math and logic functions
module alu (
  input [15:0] A, // first operand
  input [15:0] B, // second operand
  input sub, // changes addition to subtraction
  input [1:0] logSelect, // selects between logic functions
  input logic, // logic functions instead of addition
  output [15:0] R, // result
  output NE, // when used with a subtraction indicates that the operands are Not Equal
  output GE // when used with a subtraction, indicates A>= B signed

);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] R_temp;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire [3:0] s11;
  wire [3:0] s12;
  assign s4 = (A & B);
  assign s5 = (A | B);
  assign s6 = (A ^ B);
  assign s8[0] = sub;
  assign s8[1] = sub;
  assign s8[2] = sub;
  assign s8[3] = sub;
  assign s3[14:0] = A[15:1];
  assign s3[15] = B[15];
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i0 (
    .sel( logSelect ),
    .in_0( s3 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s6 ),
    .out( s2 )
  );
  assign s7[3:0] = s8;
  assign s7[7:4] = s8;
  assign s7[11:8] = s8;
  assign s7[15:12] = s8;
  assign s0 = (s7 ^ B);
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i1 (
    .a( A ),
    .b( s0 ),
    .c_i( sub ),
    .s( s1 ),
    .c_o( GE )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( logic ),
    .in_0( s1 ),
    .in_1( s2 ),
    .out( R_temp )
  );
  assign s9 = R_temp[3:0];
  assign s10 = R_temp[7:4];
  assign s11 = R_temp[11:8];
  assign s12 = R_temp[15:12];
  assign NE = ((s9[0] | s9[1] | s9[2] | s9[3]) | (s10[0] | s10[1] | s10[2] | s10[3]) | (s11[0] | s11[1] | s11[2] | s11[3]) | (s12[0] | s12[1] | s12[2] | s12[3]));
  assign R = R_temp;
endmodule

// adapts values out of registers for the ALU
module adapt (
  input [15:0] Da,
  input [15:0] Db,
  input [11:0] topImm, // bits saved from prefix
  input [3:0] rD, // rD field from current instruction
  input [3:0] rS2, // rS2 field from instruction
  input even, // force even values for PC math
  input const2, // changes 0 to 2 to increment the PC
  input selImm, // operand B is an immediate
  input selConst, // selects either 0 or 2
  input Azero,
  input immLow,
  output [15:0] A,
  output [15:0] B,
  output alt // lowest bit indicates alternative branch instruction

);
  wire [3:0] s0;
  wire alt_temp;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( Azero ),
    .in_0( Da ),
    .in_1( 16'b0 ),
    .out( A )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i1 (
    .sel( immLow ),
    .in_0( rS2 ),
    .in_1( rD ),
    .out( s0 )
  );
  assign s2[0] = 1'b0;
  assign s2[1] = const2;
  assign s2[15:2] = 14'b0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( selConst ),
    .in_0( Db ),
    .in_1( s2 ),
    .out( s3 )
  );
  assign alt_temp = s0[0];
  assign s1[0] = (~ even & alt_temp);
  assign s1[3:1] = s0[3:1];
  assign s1[15:4] = topImm;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( selImm ),
    .in_0( s3 ),
    .in_1( s1 ),
    .out( B )
  );
  assign alt = alt_temp;
endmodule

// 16 bit processor which is compatible at the assembly language level with RISC-V
module drv16 (
  input clock,
  input reset, // when high prepares the processor to execute from address 0
  input [15:0] dIn, // word coming from memory
  output [14:0] addr, // selects a 16 bit word in memory to be read or changed
  output wr, // indicates a write operation
  output [15:0] dOut, // word to be sent to memory
  output rd // indicates that memory will be read in this cycle

);
  wire [15:0] s0;
  wire s1;
  wire s2;
  wire s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire [3:0] s10;
  wire [15:0] s11;
  wire s12;
  wire s13;
  wire [15:0] s14;
  wire [15:0] s15;
  wire s16;
  wire [1:0] s17;
  wire s18;
  wire s19;
  wire [15:0] s20;
  wire [11:0] s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire [15:0] s30;
  bytes bytes_i0 (
    .dIn( dIn ),
    .sign( s2 ),
    .word( s3 ),
    .A0( s1 ),
    .fromRS2( s4 ),
    .dOut( dOut ),
    .toRD( s5 )
  );
  controlUnit controlUnit_i1 (
    .clock( clock ),
    .reset( reset ),
    .dIn( dIn ),
    .alt( s28 ),
    .NE( s12 ),
    .GE( s13 ),
    .wr( wr ),
    .rd( rd ),
    .sign( s2 ),
    .word( s3 ),
    .sub( s16 ),
    .logic( s18 ),
    .logSelect( s17 ),
    .topImm( s21 ),
    .even( s22 ),
    .const2( s23 ),
    .selImm( s24 ),
    .selConst( s25 ),
    .Azero( s26 ),
    .we( s7 ),
    .Rw( s8 ),
    .Ra( s9 ),
    .Rb( s10 ),
    .selRd( s19 ),
    .slt( s29 ),
    .immLow( s27 )
  );
  DIG_RegisterFile #(
    .Bits(16),
    .AddrBits(4)
  )
  DIG_RegisterFile_i2 (
    .Din( s6 ),
    .we( s7 ),
    .Rw( s8 ),
    .C( clock ),
    .Ra( s9 ),
    .Rb( s10 ),
    .Da( s11 ),
    .Db( s4 )
  );
  // ALU
  alu alu_i3 (
    .A( s14 ),
    .B( s15 ),
    .sub( s16 ),
    .logSelect( s17 ),
    .logic( s18 ),
    .R( s0 ),
    .NE( s12 ),
    .GE( s13 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( s19 ),
    .in_0( s20 ),
    .in_1( s5 ),
    .out( s6 )
  );
  adapt adapt_i5 (
    .Da( s11 ),
    .Db( s4 ),
    .topImm( s21 ),
    .rD( s8 ),
    .rS2( s10 ),
    .even( s22 ),
    .const2( s23 ),
    .selImm( s24 ),
    .selConst( s25 ),
    .Azero( s26 ),
    .immLow( s27 ),
    .A( s14 ),
    .B( s15 ),
    .alt( s28 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i6 (
    .sel( s29 ),
    .in_0( s0 ),
    .in_1( s30 ),
    .out( s20 )
  );
  assign s30[0] = ~ s13;
  assign s30[15:1] = 15'b0;
  assign s1 = s0[0];
  assign addr = s0[15:1];
endmodule
