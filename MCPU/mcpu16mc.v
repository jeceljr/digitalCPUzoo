/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule


module DIG_D_FF_Nbit
#(
    parameter Bits = 2,
    parameter Default = 0
)
(
   input [(Bits-1):0] D,
   input C,
   output [(Bits-1):0] Q,
   output [(Bits-1):0] \~Q
);
    reg [(Bits-1):0] state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


// single cycle version of a 16 bit MCPU. It has 4 instructions:
// - NOR
// - ADD
// - STA
// - JCC
module mcpu16mc (
  input [15:0] Instr, // Data from instruction memory
  input [15:0] Din, // word from data memory
  input clock,
  output [13:0] PC, // selects the instruction
  output [13:0] Addr, // select word from data memory
  output [15:0] Dout, // data for the data memory
  output wr // write to data memory

);
  wire [13:0] PC_temp;
  wire [13:0] s0;
  wire s1;
  wire [13:0] s2;
  wire [13:0] Addr_temp;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire [15:0] s7;
  wire s8;
  wire [15:0] Dout_temp;
  wire s9;
  wire [15:0] s10;
  wire [15:0] s11;
  assign Addr_temp = Instr[13:0];
  assign s3 = Instr[14];
  assign s4 = Instr[15];
  assign s8 = ~ s4;
  assign wr = (~ s3 & s4);
  Mux_2x1_NBits #(
    .Bits(14)
  )
  Mux_2x1_NBits_i0 (
    .sel( s1 ),
    .in_0( s2 ),
    .in_1( Addr_temp ),
    .out( s0 )
  );
  assign s1 = (s3 & s4 & ~ s6);
  // Carry
  DIG_Register DIG_Register_i1 (
    .D( s5 ),
    .C( clock ),
    .en( s3 ),
    .Q( s6 )
  );
  // Accumulator
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s7 ),
    .C( clock ),
    .en( s8 ),
    .Q( Dout_temp )
  );
  assign s5 = (s8 & s9);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( s3 ),
    .in_0( s10 ),
    .in_1( s11 ),
    .out( s7 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i4 (
    .a( Din ),
    .b( Dout_temp ),
    .c_i( 1'b0 ),
    .s( s11 ),
    .c_o( s9 )
  );
  assign s10 = ~ (Din | Dout_temp);
  // PC
  DIG_D_FF_Nbit #(
    .Bits(14),
    .Default(0)
  )
  DIG_D_FF_Nbit_i5 (
    .D( s0 ),
    .C( clock ),
    .Q( PC_temp )
  );
  DIG_Add #(
    .Bits(14)
  )
  DIG_Add_i6 (
    .a( PC_temp ),
    .b( 14'b0 ),
    .c_i( 1'b1 ),
    .s( s2 )
  );
  assign PC = PC_temp;
  assign Addr = Addr_temp;
  assign Dout = Dout_temp;
endmodule
