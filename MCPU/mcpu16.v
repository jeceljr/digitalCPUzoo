/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module mcpu16 (
  input clock,
  input [15:0] dIn,
  output wr, // indicates a write to memory
  output [13:0] Addr,
  output [15:0] dOut
);
  wire [13:0] s0;
  wire hE;
  wire [13:0] Addr_temp;
  wire [13:0] s1;
  wire s2;
  wire [13:0] s3;
  wire [15:0] s4;
  wire hA;
  wire [15:0] dOut_temp;
  wire [13:0] s5;
  wire d14;
  wire d15;
  wire [15:0] s6;
  wire s7;
  wire sULA;
  wire [15:0] s8;
  wire s9;
  wire hC;
  wire C;
  wire limpC;
  wire s10;
  wire s11;
  wire s12;
  assign s5 = dIn[13:0];
  assign d14 = dIn[14];
  assign d15 = dIn[15];
  Mux_2x1_NBits #(
    .Bits(14)
  )
  Mux_2x1_NBits_i0 (
    .sel( s2 ),
    .in_0( s3 ),
    .in_1( s5 ),
    .out( s0 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i1 (
    .a( dIn ),
    .b( dOut_temp ),
    .c_i( 1'b0 ),
    .s( s6 ),
    .c_o( s7 )
  );
  assign s8 = ~ (dIn | dOut_temp);
  DIG_Register DIG_Register_i2 (
    .D( d14 ),
    .C( clock ),
    .en( s2 ),
    .Q( s10 )
  );
  DIG_Register DIG_Register_i3 (
    .D( d15 ),
    .C( clock ),
    .en( s2 ),
    .Q( s11 )
  );
  assign sULA = ~ s10;
  assign limpC = ~ s11;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( sULA ),
    .in_0( s6 ),
    .in_1( s8 ),
    .out( s4 )
  );
  assign s9 = (limpC & s7);
  // E
  DIG_Register_BUS #(
    .Bits(14)
  )
  DIG_Register_BUS_i5 (
    .D( s0 ),
    .C( clock ),
    .en( hE ),
    .Q( Addr_temp )
  );
  // A
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( s4 ),
    .C( clock ),
    .en( hA ),
    .Q( dOut_temp )
  );
  // C
  DIG_Register DIG_Register_i7 (
    .D( s9 ),
    .C( clock ),
    .en( hC ),
    .Q( C )
  );
  assign hC = (s10 & s12);
  assign hA = (s12 & limpC);
  assign wr = (s12 & s11 & sULA);
  assign hE = ~ (s12 & s10 & s11 & ~ C);
  DIG_Add #(
    .Bits(14)
  )
  DIG_Add_i8 (
    .a( Addr_temp ),
    .b( 14'b0 ),
    .c_i( 1'b1 ),
    .s( s1 )
  );
  // CI
  DIG_Register_BUS #(
    .Bits(14)
  )
  DIG_Register_BUS_i9 (
    .D( s1 ),
    .C( clock ),
    .en( s2 ),
    .Q( s3 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i10 (
    .D( s2 ),
    .C( clock ),
    .Q( s12 ),
    .\~Q ( s2 )
  );
  assign Addr = Addr_temp;
  assign dOut = dOut_temp;
endmodule
